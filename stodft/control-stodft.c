/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/
/*                                                                          */
/*                         PI_MD:                                           */
/*             The future of simulation technology                          */
/*             ------------------------------------                         */
/*                     Module: control-stodft.c                             */
/*                                                                          */
/* This subprogram performs Stochastic DFT calculation and Geometric        */
/* Minimization.		                                            */
/*                                                                          */
/*                                                                          */
/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/

#include "standard_include.h"
#include "../typ_defs/typedefs_gen.h"
#include "../typ_defs/typedefs_cp.h"
#include "../typ_defs/typedefs_class.h"
#include "../typ_defs/typedefs_bnd.h"
#include "../typ_defs/typedefs_stat.h"
#include "../proto_defs/proto_math.h"
#include "../proto_defs/proto_communicate_wrappers.h"
#include "../proto_defs/proto_friend_lib_entry.h"
#include "../proto_defs/proto_stodft_local.h"
#include "../proto_defs/proto_frag_entry.h"

/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/
#ifdef FAST_FILTER
void controlStodftMin(CLASS *class,BONDED *bonded,GENERAL_DATA *general_data,
                                 CP *cp,ANALYSIS *analysis,
                      CLASS *class2,BONDED *bonded2,GENERAL_DATA *general_data2,
                                 CP *cp2,ANALYSIS *analysis2)
#else
void controlStodftMin(CLASS *class,BONDED *bonded,GENERAL_DATA *general_data,
                                 CP *cp,ANALYSIS *analysis)
#endif
/*=======================================================================*/
/*            Begin subprogram:                                          */
{   /*begin routine*/
/*************************************************************************/
/* This is the main driver routine of geometric minimization. It can     */
/* also be used as a main driver routine of single point calculation.	 */
/* The IO part is the same as deterministic DFT, therefore if stochastic */
/* wave functions are read in, \NSTATE_UP(DN) as to be the same as	 */
/* the number of stochastic orbitals. If deterministic wave functions    */
/* are read in or initial wave functions are generated by atomic	 */
/* orbitals, \NSTATE_UP(DN) should be the same as the number of spin	 */
/* up(dn) electrons. In this case, initial wave functions are first read */
/* in/generated and initial density is generated. After that, the	 */
/* nstate_up(dn) is replaced by the number of stochastic orbitals	 */
/* numStateStoUp(Dn) and all arrays w.r.t. wave functions are realloc.	 */
/*************************************************************************/
/*=======================================================================*/
/*            Local variable declarations                                */

#include "../typ_defs/typ_mask.h"

  MPI_Comm comm_states = class->communicate.comm_states;
  MPI_Comm world       = class->communicate.world;

  STAT_AVG *stat_avg = &(general_data->stat_avg);
  STODFTINFO *stodftInfo;
  STODFTCOEFPOS *stodftCoefPos;
  FRAGINFO *fragInfo;
  CPOPTS *cpOpts = &(cp->cpopts);

  GENERAL_DATA **generalDataMiniPoint = (GENERAL_DATA**)cmalloc(sizeof(GENERAL_DATA*));
  CP **cpMiniPoint = (CP**)cmalloc(sizeof(CP*));
  CLASS **classMiniPoint = (CLASS**)cmalloc(sizeof(CLASS*));
  ANALYSIS **analysisMiniPoint = (ANALYSIS**)cmalloc(sizeof(ANALYSIS*));
  BONDED **bondedMiniPoint = (BONDED**)cmalloc(sizeof(BONDED*));
  
  int cpLsda = cpOpts->cp_lsda;
  int myid = class->communicate.myid;
  int numProc = cp->communicate.np;
  int numTime = general_data->timeinfo.ntime;
  int fragWindowFlag;
  int readCoeffFlag;
  int iTime;
  int ip_now = 1;
  int reInitFlag;
  int filterDiagFlag;
  int calcFragFlag;
  int checkpointParFlag;

  double elecEnergy,elecEnergyOld,elecEnergyOldTemp,elecEnergyTemp;
  double deltaEnergy;


  // debug
  CPCOEFFS_POS  *cpcoeffs_pos   = &(cp->cpcoeffs_pos[ip_now]);
  CLATOMS_POS  *clatoms_pos  = &(class->clatoms_pos[ip_now]);
  CPCOEFFS_INFO *cpcoeffs_info  = &(cp->cpcoeffs_info);
  //end debug

/*======================================================================*/
/* I) Write to Screen                                                   */

 if(myid==0){
   PRINT_LINE_STAR;
   printf("Running Stochastic DFT.\n");
   PRINT_LINE_DASH;
 }/* endif */

/*======================================================================*/
/* II) Initialize the stochastic DFT                                    */

  if(numProc>1)commStodft(class,bonded,general_data,cp);

  initStodft(class,bonded,general_data,cp,ip_now);
  reInitFlag = cp->stodftInfo->reInitFlag;
  stodftInfo = cp->stodftInfo;
  stodftCoefPos = cp->stodftCoefPos;
  //exit(0);

  //fflush(stdout);
  //exit(0);
/*======================================================================*/
/* III) Calculate initial density			                */

  readCoeffFlag = stodftInfo->readCoeffFlag;
  fragWindowFlag = stodftInfo->fragWindowFlag;
  //printf("readCoeffFlag %i\n",readCoeffFlag);
  //If I'm not reading checkpoint file, calculate initial density
  if(readCoeffFlag!=-3)calcRhoInit(class,bonded,general_data,cp,ip_now);
  //exit(0);
  //debug only
  /*
  STODFTINFO *stodftInfo = cp->stodftInfo;
  STODFTCOEFPOS *stodftCoefPos  = cp->stodftCoefPos;
  double *coeffReUpBackup;
  double *coeffImUpBackup;
  double *coeffReUp = cpcoeffs_pos->cre_up;
  double *coeffImUp = cpcoeffs_pos->cim_up;
  double length;
  int iState,iCoeff;
  int numStateUpProc = cpcoeffs_info->nstate_up_proc;
  int numStateDnProc = cpcoeffs_info->nstate_dn_proc;
  int numCoeff       = cpcoeffs_info->ncoef;
  int numCoeffUpTot   = numStateUpProc*numCoeff;
  int numCoeffDnTot   = numStateDnProc*numCoeff;

  genEigenOrb(cp,class,general_data,cpcoeffs_pos,clatoms_pos);

  stodftCoefPos->coeffReUpBackup = (double*)cmalloc((numCoeffUpTot+1)*sizeof(double));
  stodftCoefPos->coeffImUpBackup = (double*)cmalloc((numCoeffUpTot+1)*sizeof(double));
  coeffReUpBackup = stodftCoefPos->coeffReUpBackup;
  coeffImUpBackup = stodftCoefPos->coeffImUpBackup;

  for(iState=0;iState<numStateUpProc;iState++){
    length = 0.0;
    for(iCoeff=1;iCoeff<numCoeff;iCoeff++){
      length += coeffReUp[iState*numCoeff+iCoeff]*coeffReUp[iState*numCoeff+iCoeff]+
                coeffImUp[iState*numCoeff+iCoeff]*coeffImUp[iState*numCoeff+iCoeff];
    }
    length *= 2.0;
    length += coeffReUp[iState*numCoeff+numCoeff]*coeffReUp[iState*numCoeff+numCoeff];
    length = sqrt(length);
    for(iCoeff=1;iCoeff<=numCoeff;iCoeff++){
      coeffReUp[iState*numCoeff+iCoeff] /= length;
      coeffImUp[iState*numCoeff+iCoeff] /= length;
    }
  }

  for(iCoeff=1;iCoeff<=numCoeffUpTot;iCoeff++){
    coeffReUpBackup[iCoeff] = coeffReUp[iCoeff];
    coeffImUpBackup[iCoeff] = coeffImUp[iCoeff];
  }
  */
  //end debug

#ifdef FAST_FILTER
  if(numProc>1)commStodft(class2,bonded2,general_data2,cp2);

  initStodft(class2,bonded2,general_data2,cp2,ip_now);
  int reInitFlag2 = cp2->stodftInfo->reInitFlag;
  STODFTINFO *stodftInfo2 = cp2->stodftInfo;
  STODFTCOEFPOS *stodftCoefPos2 = cp2->stodftCoefPos;
#endif

/*======================================================================*/
/* IV) Realloc wave function arrays if necessary		        */
  
  //if(reInitFlag==1){
  // I found that I've put some important memory allocation in reInitWaveFunMin. 
  // Therefore I enforce doing this for every initial condition. But reInitFlag 
  // is used within reInitWaveFunMin to prevent redo initialization for certain 
  // flags
  if(myid==0){
    PRINT_LINE_STAR;
    printf("Reinit wave function\n");
    PRINT_LINE_DASH;
  }
  reInitWaveFunMin(class,bonded,general_data,cp,ip_now);
  //}

#ifdef FAST_FILTER
  reInitWaveFunMin(class2,bonded2,general_data2,cp2,ip_now);
  initFilterDiag(cp2);
#endif

  //filterDiagFlag = 0;
  filterDiagFlag = cp->stodftInfo->filterDiagFlag;
  if(filterDiagFlag==1){
    initFilterDiag(cp);
  }


  //exit(0);
/*======================================================================*/
/* V) If needed, calculate the fragmentation                            */

  calcFragFlag = cp->stodftInfo->calcFragFlag;
  //printf("calcFragFlag %i\n",calcFragFlag);
  if(calcFragFlag==1){
    if(myid==0){
      PRINT_LINE_STAR;
      printf("Initial fragment calculation\n");
      PRINT_LINE_DASH;
    }
    if(readCoeffFlag!=-3||fragWindowFlag==1){// don't read checkpoint file 
      initFrag(class,bonded,general_data,cp,analysis,classMiniPoint,bondedMiniPoint,
		  generalDataMiniPoint,analysisMiniPoint,cpMiniPoint,ip_now);

      // We need to generate noise wave function one time before we do the projection
      //genNoiseOrbital(cp,&(cp->cpcoeffs_pos[ip_now]));
      //Barrier(comm_states);
      //fflush(stdout);
      //exit(0);
      fragScf(class,bonded,general_data,cp,analysis,*generalDataMiniPoint,
	      *cpMiniPoint,*classMiniPoint,*analysisMiniPoint,*bondedMiniPoint,ip_now);
      // Output fragmentation checkpoint
      checkpointFragOutput(cp,class);
    }
    else{
      checkpointFragInput(cp,class);
    }
    // Reset readCoeffFlag
    readCoeffFlag = stodftInfo->readCoeffFlag;
    if(readCoeffFlag==-1){
      calcRhoFragInit(class,bonded,general_data,cp,ip_now);
    }
  }
  //exit(0);

/*======================================================================*/
/* IV) Electronic Structure calculation for initial configuration       */

  // After we move initial density calculation above, this function is 
  // no longer needed.
  if(myid==0){
    PRINT_LINE_STAR;
    printf("Initial SP\n");
    PRINT_LINE_DASH;
  }
  
  if(readCoeffFlag==-3){
    checkpointParFlag = stodftInfo->checkpointParFlag;
    if(checkpointParFlag==0)checkpointInput(cp,general_data,class); 
    else checkpointInputDist(cp,general_data,class);
  }
  if(filterDiagFlag==0){
    if(stodftInfo->chemPotOpt==1){
#ifdef FAST_FILTER   
      scfStodftInterp(class,bonded,general_data,cp,
                      class2,bonded2,general_data2,cp2,ip_now);
#else
      scfStodftInterp(class,bonded,general_data,cp,ip_now);
#endif
    }
    else if(stodftInfo->chemPotOpt==2){
      if(stodftInfo->energyWindowOn==0){
#ifdef FAST_FILTER   
        scfStodftCheby(class,bonded,general_data,cp,
                       class2,bonded2,general_data2,cp2,ip_now);
#else
        scfStodftCheby(class,bonded,general_data,cp,ip_now);
#endif
      }
      else{ //energy window
        printf("fragWindowFlag %i\n",stodftInfo->fragWindowFlag);
        if(stodftInfo->fragWindowFlag==0){
#ifdef FAST_FILTER   
          scfStodftEnergyWindow(class,bonded,general_data,cp,
                                class2,bonded2,general_data2,cp2,ip_now);
#else
          scfStodftEnergyWindow(class,bonded,general_data,cp,
                                ip_now);
#endif  
        }
        else{
#ifdef FAST_FILTER   
          scfStodftEnergyWindowFrag(class,bonded,general_data,
                    cp,class2,bonded2,general_data2,cp2,
                    *cpMiniPoint,*generalDataMiniPoint,*classMiniPoint,
                    ip_now);
#else     
          scfStodftEnergyWindowFrag(class,bonded,general_data,
                    cp,*cpMiniPoint,*generalDataMiniPoint,*classMiniPoint,
                    ip_now);
#endif
        }//endif fragWindowFlag
      }//endif energyWindowOn
    }//endif chemPotOpt  
  }//endif filterDiagFlag
  else scfStodftFilterDiag(class,bonded,general_data,cp,ip_now);
  //scfStodft(class,bonded,general_data,cp,ip_now);
   
/*======================================================================*/
/* V) Loop over the specified number of time steps for geometric	*/
/*    optimization.							*/
 
  numTime = 0; //I don't want to see this loop in today's debug
  for(iTime=1;iTime<numTime;iTime++){

  /*---------------------------------------------------------------------*/
  /* 1) Update Atom Coordinate                                           */

//Let's temperaly test the filter by given the density and chemical potential, test how the filter looks like on KS eigenfunctions. 

  /*---------------------------------------------------------------------*/
  /* 2) Run SCF calculation                                              */

  elecEnergyOld     = stat_avg->cp_eke
	              + stat_avg->cp_enl
		      + stat_avg->cp_ehart
		      + stat_avg->cp_exc
		      + stat_avg->cp_eext;

  if(numProc>1){
   elecEnergyOldTemp = elecEnergyOld;
   Allreduce(&(elecEnergyOldTemp),&(elecEnergyOld),1,MPI_DOUBLE,MPI_SUM,0,
	     comm_states);
  }/*endif*/

  //Minimize with stochastic dft
  //scfStodftInterp(class,bonded,general_data,cp,ip_now);
  elecEnergy     = stat_avg->cp_eke
		 + stat_avg->cp_enl
		 + stat_avg->cp_ehart
		 + stat_avg->cp_exc
		 + stat_avg->cp_eext;
  if(numProc>1){
   elecEnergyTemp = elecEnergy;
   Allreduce(&(elecEnergyTemp),&(elecEnergy),1,MPI_DOUBLE,MPI_SUM,0,comm_states);
  }/*endif*/
  deltaEnergy = fabs(elecEnergy-elecEnergyOld);

  /*----------------------------------------------------------------------*/
  /*   6)Calculate some simple averages                                   */

  /*-----------------------------------------------------------------------*/
  /*   7)Produce the output specified by the user                          */


  /*---------------------------------------------------------------------*/
  /*  8) Analysis Routine                                               */

 /*---------------------------------------------------------------------*/
 /*   Check for exit condition                                      */

  }//endfor iTime

  /*======================================================================*/
  /*  II) Final dump  : get all energyies and write EVERYTHING            */

  /*======================================================================*/
  /*  III)Write to Screen                                                 */

  if(myid==0){
    PRINT_LINE_DASH;
    printf("Completed Stochastic DFT run \n");
    PRINT_LINE_STAR;
  }/* endif */

/*-----------------------------------------------------------------------*/
}/*end routine*/
/*==========================================================================*/






