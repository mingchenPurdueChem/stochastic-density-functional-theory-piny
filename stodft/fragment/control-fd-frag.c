/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/
/*                                                                          */
/*                         PI_MD:                                           */
/*             The future of simulation technology                          */
/*             ------------------------------------                         */
/*                     Module: control-stodft.c                             */
/*                                                                          */
/* This subprogram performs Stochastic DFT calculation and Geometric        */
/* Minimization. This is a version used from fragments. Because we may      */
/* use fake filter with macros, we want to avoid using the same macro for   */
/* fragment DFT calculation.                                                */
/*                                                                          */
/*                                                                          */
/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/

#include "standard_include.h"
#include "../typ_defs/typedefs_gen.h"
#include "../typ_defs/typedefs_cp.h"
#include "../typ_defs/typedefs_class.h"
#include "../typ_defs/typedefs_bnd.h"
#include "../typ_defs/typedefs_stat.h"
#include "../proto_defs/proto_math.h"
#include "../proto_defs/proto_communicate_wrappers.h"
#include "../proto_defs/proto_friend_lib_entry.h"
#include "../proto_defs/proto_stodft_local.h"
#include "../proto_defs/proto_frag_local.h"


/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/
void controlStodftMinfrag(CLASS *class,BONDED *bonded,GENERAL_DATA *general_data,
                                 CP *cp,ANALYSIS *analysis)
/*=======================================================================*/
/*            Begin subprogram:                                          */
{   /*begin routine*/
/*************************************************************************/
/* This is the main driver routine of geometric minimization. It can     */
/* also be used as a main driver routine of single point calculation.	 */
/* The IO part is the same as deterministic DFT, therefore if stochastic */
/* wave functions are read in, \NSTATE_UP(DN) as to be the same as	 */
/* the number of stochastic orbitals. If deterministic wave functions    */
/* are read in or initial wave functions are generated by atomic	 */
/* orbitals, \NSTATE_UP(DN) should be the same as the number of spin	 */
/* up(dn) electrons. In this case, initial wave functions are first read */
/* in/generated and initial density is generated. After that, the	 */
/* nstate_up(dn) is replaced by the number of stochastic orbitals	 */
/* numStateStoUp(Dn) and all arrays w.r.t. wave functions are realloc.	 */
/*************************************************************************/
/*=======================================================================*/
/*            Local variable declarations                                */

#include "../typ_defs/typ_mask.h"

  MPI_Comm comm_states = class->communicate.comm_states;
  MPI_Comm world       = class->communicate.world;

  STAT_AVG *stat_avg = &(general_data->stat_avg);
  // we can do this since numProc=1 for fragment
  STODFTINFO *stodftInfo = cp->stodftInfo;
  STODFTCOEFPOS *stodftCoefPos = cp->stodftCoefPos;
  CPOPTS *cpOpts = &(cp->cpopts);
  FRAGINFO *fragInfo = stodftInfo->fragInfo;
  
  int cpLsda = cpOpts->cp_lsda;
  int myid = class->communicate.myid;
  int numProc = cp->communicate.np;
  int numTime = general_data->timeinfo.ntime;
  int fragWindowFlag;
  int iFrag = fragInfo->iFrag; //This iFrag is global index 
  int readCoeffFlag;
  int iTime;
  int ip_now = 1;
  int reInitFlag;
  int filterDiagFlag;
  int calcFragFlag;
  int checkpointParFlag;
  // redirect stdout
  int saved_stdout,saved_stderr;
  int fout,ferr;
  FILE *fragScreenOut;
  char fileScreenFrag[100];
  char fileScreenErr[100];

  double elecEnergy,elecEnergyOld,elecEnergyOldTemp,elecEnergyTemp;
  double deltaEnergy;


  // debug
  CPCOEFFS_POS  *cpcoeffs_pos   = &(cp->cpcoeffs_pos[ip_now]);
  CLATOMS_POS  *clatoms_pos  = &(class->clatoms_pos[ip_now]);
  CPCOEFFS_INFO *cpcoeffs_info  = &(cp->cpcoeffs_info);
  //end debug

/*======================================================================*/
/* I) Write to Screen                                                   */

  //DEBUG
  printf("111111111111111111\n"); 
  sprintf(fileScreenFrag,"frag-screen-%i",iFrag);
  sprintf(fileScreenErr,"frag-screen-error-%i",iFrag);
  fout = open(fileScreenFrag,O_RDWR|O_CREAT, 0600);
  ferr = open(fileScreenErr,O_RDWR|O_CREAT, 0600);
  fflush(stdout);
  saved_stdout = dup(fileno(stdout));
  saved_stderr = dup(fileno(stderr));
  dup2(fout,fileno(stdout));
  dup2(ferr,fileno(stderr));
  

  if(myid==0){
    PRINT_LINE_STAR; 
    printf("Running DFT For Fragment %i.\n",iFrag);
    PRINT_LINE_STAR; 
  }// endif

/*======================================================================*/
/* II) Initialize the stochastic DFT                                    */

  printf("111111111111111111\n");
  fflush(stdout);
  if(numProc>1)commStodft(class,bonded,general_data,cp);


  printf("111111111111111111\n");
  fflush(stdout);

  initStodft(class,bonded,general_data,cp,ip_now);
  reInitFlag = cp->stodftInfo->reInitFlag;
  stodftInfo = cp->stodftInfo;
  stodftCoefPos = cp->stodftCoefPos;
   
  //exit(0);

  //fflush(stdout);
  //exit(0);
/*======================================================================*/
/* III) Calculate initial density			                */

  printf("111111111111111111\n");
  fflush(stdout);
  readCoeffFlag = stodftInfo->readCoeffFlag;
  printf("rrrrrrrrrrreadCoeffFlag %i\n",readCoeffFlag);
  fragWindowFlag = stodftInfo->fragWindowFlag;
  if(readCoeffFlag!=-3)calcRhoInit(class,bonded,general_data,cp,ip_now);
  //exit(0);

/*======================================================================*/
/* IV) Realloc wave function arrays if necessary		        */
  
  //if(reInitFlag==1){
  // I found that I've put some important memory allocation in reInitWaveFunMin. 
  // Therefore I enforce doing this for every initial condition. But reInitFlag 
  // is used within reInitWaveFunMin to prevent redo initialization for certain 
  // flags
  if(myid==0){
    PRINT_LINE_STAR;
    printf("Reinit wave function\n");
    PRINT_LINE_STAR;
  }
  reInitWaveFunMin(class,bonded,general_data,cp,ip_now);
  //}

  //filterDiagFlag = 0;
  filterDiagFlag = cp->stodftInfo->filterDiagFlag;
  if(filterDiagFlag==1){
    initFilterDiag(cp);
  }


  //exit(0);
/*======================================================================*/
/* V) If needed, calculate the fragmentation                            */

/*======================================================================*/
/* IV) Electronic Structure calculation for initial configuration       */

  // After we move initial density calculation above, this function is 
  // no longer needed.
  if(myid==0){
    PRINT_LINE_STAR;
    printf("Initial SP\n");
    PRINT_LINE_DASH;
  }
  
  if(readCoeffFlag==-3){
    checkpointParFlag = stodftInfo->checkpointParFlag;
    if(checkpointParFlag==0)checkpointInput(cp,general_data,class); 
    else checkpointInputDist(cp,general_data,class);
  }

  scfStodftFilterDiag(class,bonded,general_data,cp,ip_now);

  scaleFragWf(class,general_data,cp,ip_now);
   
/*======================================================================*/
/*  III)Write to Screen                                                 */

  if(myid==0){
    PRINT_LINE_DASH;
    printf("Completed DFT run \n");
    PRINT_LINE_STAR;
  }/* endif */

  fflush(stdout);

  //DEBUG
  
  dup2(saved_stdout,fileno(stdout));
  dup2(saved_stderr,fileno(stderr));
   
/*-----------------------------------------------------------------------*/
}/*end routine*/
/*==========================================================================*/

/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/
void scaleFragWf(CLASS *class,GENERAL_DATA *general_data,CP *cp,int ip_now)
/*=======================================================================*/
/*            Begin subprogram:                                          */
{   /*begin routine*/
/*************************************************************************/
/* Scale the wavefunction. Current scaling is sqrt(2f) while we need     */
/* f^0.25 as scaling. We are doing it here so that we don't need to do   */
/* it when transfering to real space representation.                     */
/*************************************************************************/
  STODFTINFO *stodftInfo = cp->stodftInfo;
  CPCOEFFS_INFO *cpcoeffs_info = &(cp->cpcoeffs_info);
  
  int iState,iCoeff;
  int numStateUpFrag = cpcoeffs_info->nstate_up_proc;
  int numCoeff = cpcoeffs_info->ncoef;
  double *ccrealUp        = cp->cpcoeffs_pos[ip_now].cre_up;
  double *ccimagUp        = cp->cpcoeffs_pos[ip_now].cim_up;
  double *ccrealDn        = cp->cpcoeffs_pos[ip_now].cim_dn;
  double *ccimagDn        = cp->cpcoeffs_pos[ip_now].cim_dn;

  double *numOccDetProc = stodftInfo->numOccDetProc;
  double occPre;
  for(iState=0;iState<numStateUpFrag;iState++){
    if(numOccDetProc[iState]>1.0e-20){
      occPre = sqrt(sqrt(2.0))/sqrt(numOccDetProc[iState]);
    }
    else{
      occPre = 0.0;
    }
    for(iCoeff=1;iCoeff<=numCoeff;iCoeff++){
      ccrealUp[iCoeff] *= occPre;
      ccimagUp[iCoeff] *= occPre;
    }    
  }
  // DEBUG: LSDA NOT APPLIED


/*-----------------------------------------------------------------------*/
}/*end routine*/
/*==========================================================================*/

